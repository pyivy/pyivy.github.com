---
layout: post
title: "发现数学之美"
description: "<p>真正有价值的应用，都不是简单的增删改查，大部分都蕴含着对现实世界深刻的分析，有着复杂的数学计算。那些最伟大的程序员，很多场合都称自己其实是数学家。</p><p>然而，我们的数学知识，是不是早还给老师了？</p><p>在最近的分享中，我有意识的提醒大家注重数学的学习，趁自己大脑中残存的那些数学概念还没有完全灭失的时候，捡一些回来，就算你真的在开发中应用不上，也能锻炼自己的逻辑思维能力。</p><p>以后的招聘中，英语和数学，是必须考核的两个重要标准。</p>"
category: python
tags: [math, gcd]
---
{% include JB/setup %}

我发现很多工作一年多的程序员，学会了 CRUD，在 MyEclipe 的帮助下能用 SSH，可以写一个博客什么的，就以为自己学会编程了，在简历中声称精通 Java 的，大有人在。

你问他，16 * 12 等于多少？他很可能答不出来，甚至在纸上都不一定能算对，让人痛心疾首。

殊不知，真正有价值的应用，都不是简单的增删改查，大部分都蕴含着对现实世界深刻的分析，有着复杂的数学计算。那些最伟大的程序员，很多场合都称自己其实是数学家。

然而，我们的数学知识，是不是早还给老师了？

所以在最近的分享中，我有意识的提醒大家注重数学的学习，趁自己大脑中残存的那些数学概念还没有完全灭失的时候，捡一些回来，就算你真的在开发中应用不上，也能锻炼自己的逻辑思维能力。

以后的招聘中，英语和数学，是必须考核的两个重要标准。

在这里，我们先讨论一个小学的数学概念，求两个数的最大公约数，和最小公倍数。

如果是纸上运算，我们最先想到的方法，就是短除法，简单，有效。倘若你喜欢分解质因数，也行，但是分解质因数不用短除法，也不简单。

关于短除法，[这里](http://www.slideshare.net/bruno921/ss-14819754)有一个 Presentation，台湾老师的作品，相当不错，如果你没有梯子，可以看我复制的 [PDF](/assets/images/2013/02/short-division.pdf) 版本（5.6 M）。

两个数的最大公数和最小公倍数，相对比较好计算，三个数呢？

参考这个[视频](http://www.youtube.com/watch?v=fX6YC-r2MIw)。

>[小数爱好者007](http://www.sowerclub.com/ViewTopic.php?id=452306)：求最大公因数和最小公倍数，除数是用较大的合数还是必须用质数，个人认为求两个数的最小公倍数和最大公因数都是可以的的，但是 **求三个数的最小公倍数必须用先选取三个数公有的质因数，把三个数公有的质因数都找尽了，再找两个数公有的质因数，直到除到三个数两两互质为止。**

我们是程序员，当然不能满足于纸上运算，这里给出几个 Python 的算法：

```python
# coding: utf-8


# 大公约数递归算法
def gcd(num1, num2):
    if num2 == 0:
        return num1
    else:
        return gcd(num2, num1 % num2)


# 最小公倍数算法
def lcm(num1, num2):
    tmp = gcd(num1, num2)
    return num1 * num2 / tmp


# 欧几里德算法
def gcd_Euclid(m, n):
    while n:
        m, n = n, m % n
    return m


# 欧几里德的Python语言描述
def gcd_Python(a, b):
    if a < b:
        a, b = b, a

    while b != 0:
        temp = a % b
        a = b
        b = temp

    return a


#  Stein 算法
def gcd_Stein(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    if a % 2 == 0 and b % 2 == 0:
        return 2 * gcd_Stein(a / 2, b / 2)
    if a % 2 == 0:
        return gcd_Stein(a / 2, b)
    if b % 2 == 0:
        return gcd_Stein(a, b / 2)

    return gcd_Stein((a + b) / 2, (a - b) / 2)


print gcd_Stein(180, 356)
print lcm(180, 356)
```

欧几里德算法又称辗转相除法，用于计算两个整数a, b的最大公约数。其计算原理依赖于下面的定理：

`gcd(a, b) = gcd(b, a mod b)`

欧几里德算法是计算两个数最大公约数的传统算法，无论是理论，还是从效率上都是很好的。但是他有一个致命的缺陷，这个缺陷只有在很大的素数时才会显现出来。

考虑现在的硬件平台，一般整数最多也就是64位， 对于这样的整数，计算两个数值就的模很简单的。对于字长为32位的平台，计算两个不超过32位的整数的模，只需要一个指令周期，而计算64位以下的整数模，也不过几个周期而已。但是对于更大的素数，这样的计算过程就不得不由用户来设计，为了计算两个超过64位的整数的模，用户也许不得不采用类似于多位除法手算过程中的试商法，这个过程不但复杂，而且消耗了很多CPU时间。对于现代密码算法，要求计算128位以上的素数的情况比比皆是，设计这样的程序迫切希望能够抛弃除法和取模。

Stein 算法由 J.Stein 1961年提出，这个方法也是计算两个数的最大公约数。和欧几里德算法不同的是，Stein 算法只有整数的移位和加减法，这对于程序设计者是一个福音。

我在查这些资料的时候，在百度文库上发现了一个不错的 PPT，[神奇的数字 - 从数字赏数学之美](http://wenku.baidu.com/view/e53a236e58fafab069dc0221.html)，只是设计不够精致，也有一些小错误，于是我复制了一份，见[这里](http://www.chenzixin.com/demo/slides/math.html)。

仔细看完，你可能会放弃对数学的偏见，甚至改变对数学的看法。

伯特兰·罗素以下列文字来形容他对数学之美的感觉：

<p class='justify'>Mathematics, rightly viewed, possesses not only truth, but supreme beauty — a beauty cold and austere, like that of sculpture, without appeal to any part of our weaker nature, without the gorgeous trappings of painting or music, yet sublimely pure, and capable of a stern perfection such as only the greatest art can show. The true spirit of delight, the exaltation, the sense of being more than Man, which is the touchstone of the highest excellence, is to be found in mathematics as surely as poetry. (The Study of Mathematics, in Mysticism and Logic, and Other Essays, ch. 4, London: Longmans, Green, 1918.)</p>

翻译：数学，如果正确地看它，则具有……至高无上的美——正像雕刻的美，是一种冷而严肃的美，这种美不是投合我们天性的微弱的方面，这种美没有绘画或音乐的那些华丽的装饰，它可以纯净到崇高的地步，能够达到严格的只有最伟大的艺术才能显示的那种完美的境地。一种真实的喜悦的精神，一种精神上的亢奋，一种觉得高于人的意识——这些是至善至美的标准，能够在诗里得到，也能够在数学里得到。（研究数学，在神秘主义和逻辑，与其他论文，概括。4、伦敦：中国政法大学，格林，1918年。）

再看下面这些算式：

```
1 x 8 + 1 = 9
12 x 8 + 2 = 98
123 x 8 + 3 = 987
1234 x 8 + 4 = 9876
12345 x 8 + 5 = 98765
123456 x 8 + 6 = 987654
1234567 x 8 + 7 = 9876543
12345678 x 8 + 8 = 98765432
123456789 x 8 + 9 = 987654321

1 x 9 + 2 = 11
12 x 9 + 3 = 111
123 x 9 + 4 = 1111
1234 x 9 + 5 = 11111
12345 x 9 + 6 = 111111
123456 x 9 + 7 = 1111111
1234567 x 9 + 8 = 11111111
12345678 x 9 + 9 = 111111111
123456789 x 9 +10 = 1111111111

9 x 9 + 7 = 88
98 x 9 + 6 = 888
987 x 9 + 5 = 8888
9876 x 9 + 4 = 88888
98765 x 9 + 3 = 888888
987654 x 9 + 2 = 8888888
9876543 x 9 + 1 = 88888888
98765432 x 9 + 0 = 888888888

1 x 1 = 1
11 x 11 = 121
111 x 111 = 12321
1111 x 1111 = 1234321
11111 x 11111 = 123454321
111111 x 111111 = 12345654321
1111111 x 1111111 = 1234567654321
11111111 x 11111111 = 123456787654321
111111111 x 111111111 = 12345678987654321

3 x 4 = 12
33 x 34 = 1122
333 x 334 = 111222
3333 x 3334 = 11112222
33333 x 33334 = 1111122222
333333 x 333334 = 111111222222

142857 x 1 = 142857
142857 x 2 = 285714
142857 x 3 = 428571
142857 x 4 = 571428
142857 x 5 = 714285
142857 x 6 = 857142
142857 x 7 = 999999

11 x 101 = 1111
12 x 101 = 1212
13 x 101 = 1313
14 x 101 = 1414
15 x 101 = 1515
16 x 101 = 1616
17 x 101 = 1717
18 x 101 = 1818
19 x 101 = 1919
20 x 101 = 2020
```

最后我们看一道台湾國小四年級的数学题：

大雄、胖虎、小夫三个人练习桌球，从早上10:20练习到11:20，每次练习时两人对打，请问其间每人平均练习的时间为多少？

60 分钟 / 3 人 = 20 分钟/人

错！是对打，所以，每人平均练习时间，20 分钟 * 2 = 40 分钟。

乘以 2 是简单有效的算法，如果分解开来，反而把自己绕进去了。

你还能想到更简单的算法吗？






